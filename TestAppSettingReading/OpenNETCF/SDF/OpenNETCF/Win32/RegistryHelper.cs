using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Win32;
using System.IO;
using System.Runtime.InteropServices;

namespace OpenNETCF.Win32
{
    /// <summary>
    /// Contains methods for working with the system registry.
    /// </summary>
    public static class RegistryHelper
    {
        /// <summary>
        /// This function saves a copy of the current Windows CE RAM–based registry to a specified file.
        /// </summary>
        /// <param name="destinationPath">Specifies the name of the file to which the registry is saved</param>
        public static void SaveRamBasedRegistry(string destinationPath)
        {
            if (destinationPath == null)
            {
                throw new ArgumentNullException();
            }

            if (!NativeMethods.RegCopyFile(destinationPath))
            {
                throw new System.ComponentModel.Win32Exception(System.Runtime.InteropServices.Marshal.GetLastWin32Error(), "Unable to generate registry file");
            }
        }

        /// <summary>
        /// This function putrs the OS in a state that it will load the specified registry on the next boot.
        /// </summary>
        /// <param name="sourcePath">Path to the source registry file generated by a call to <see cref="SaveRamBasedRegistry"/></param>
        /// <remarks>The device <b>will</b> be soft reset when this overload of the function is called</remarks>
        public static void RestoreRamBasedRegistry(string sourcePath)
        {
            RestoreRamBasedRegistry(sourcePath, true);
        }

        /// <summary>
        /// This function putrs the OS in a state that it will load the specified registry on the next boot.
        /// </summary>
        /// <param name="sourcePath">Path to the source registry file generated by a call to <see cref="SaveRamBasedRegistry"/></param>
        /// <param name="performReset">If true, the device will soft reset when the method is called to complete the update</param>
        /// <remarks>The device *must* be soft reset for the registry to actually be restored</remarks>
        public static void RestoreRamBasedRegistry(string sourcePath, bool performReset)
        {
            if (sourcePath == null)
            {
                throw new ArgumentNullException();
            }

            if (!File.Exists(sourcePath))
            {
                throw new FileNotFoundException("File '" + sourcePath + "' not found");
            }

            if(!NativeMethods.RegRestoreFile(sourcePath))
            {
                throw new System.ComponentModel.Win32Exception(System.Runtime.InteropServices.Marshal.GetLastWin32Error(), "Unable to restore from specified registry file");
            }

            if (performReset)
            {
                // TODO: soft reset
            }
        }

        /// <summary>
        /// This function saves the specified key and all of its subkeys and values to a new file. If the specified key is not a predefined ROOT, it backs up to the ROOT of the keyToSave and saves there.
        /// </summary>
        /// <param name="keyToSave">Specifies a handle to the key where the save operation is to begin, or any of the following predefined reserved handle values:
        /// <list type="Root Keys">
        /// <item><see cref="Registry.LocalMachine"/></item>
        /// <item><see cref="Registry.CurrentUser"/></item>
        /// <item><see cref="Registry.ClassesRoot"/></item>
        /// <item><see cref="Registry.Users"/></item>
        /// </list>
        /// </param>
        /// <param name="destinationPath">Specifies the name of the file to which the registry key will be saved</param>
        public static void SaveHiveBasedKey(RegistryKey keyToSave, string destinationPath)
        {
            if ((destinationPath == null) || (keyToSave == null))
            {
                throw new ArgumentNullException();
            }

            uint root = 0;

            // find what the root of the key is
            if (keyToSave.Name.IndexOf("HKEY_LOCAL_MACHINE") >= 0)
            {
                root = (uint)NativeMethods.RootKeys.LocalMachine;
            }
            else if (keyToSave.Name.IndexOf("HKEY_CLASSES_ROOT") >= 0)
            {
                root = (uint)NativeMethods.RootKeys.ClassesRoot;
            }
            else if (keyToSave.Name.IndexOf("HKEY_CURRENT_USER") >= 0)
            {
                root = (uint)NativeMethods.RootKeys.CurrentUser;
            }
            else if(keyToSave.Name.IndexOf("HKEY_USERS") >= 0)
            {
                root = (uint)NativeMethods.RootKeys.Users;
            }

			if (NativeMethods.RegSaveKey(root, destinationPath, IntPtr.Zero) != 0)
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error(), "Unable to generate registry file");
            }
        }

        /// <summary>
        /// This function replaces the file backing a registry key and all its subkeys with another file, so that when the OS is next started, the key and subkeys will have the values stored in the new file.
        /// </summary>
        /// <param name="sourcePath">Path to the source registry file generated by a call to <see cref="SaveRamBasedRegistry"/></param>
        /// <remarks>The device <b>will</b> be soft reset when this overload of the function is called</remarks>
        public static void RestoreHiveBasedKey(string sourcePath)
        {
            RestoreHiveBasedKey(sourcePath, true);
        }

        /// <summary>
        /// This function replaces the file backing a registry key and all its subkeys with another file, so that when the OS is next started, the key and subkeys will have the values stored in the new file.
        /// </summary>
        /// <param name="sourcePath">Path to the source registry file generated by a call to <see cref="SaveRamBasedRegistry"/></param>
        /// <param name="performReset">If true, the device will soft reset when the method is called to complete the update</param>
        /// <remarks>The device *must* be soft reset for the registry to actually be restored</remarks>
        public static void RestoreHiveBasedKey(string sourcePath, bool performReset)
        {
            if (sourcePath == null)
            {
                throw new ArgumentNullException();
            }

            if (!File.Exists(sourcePath))
            {
                throw new FileNotFoundException("File '" + sourcePath + "' not found");
            }

            if(!NativeMethods.RegReplaceKey((uint)NativeMethods.RootKeys.LocalMachine, IntPtr.Zero, sourcePath, IntPtr.Zero))
            {
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error(), "Unable to restore from specified registry file");
            }

            if (performReset)
            {
                // TODO: soft reset
            }
        }

        #region Create Volatile SubKey
        /// <summary>
        /// Creates a new volatile subkey for the specified registry key.
        /// <para>Requires Windows CE 5.0</para>
        /// </summary>
        /// <param name="key">Existing parent key.</param>
        /// <param name="name">The name or path of the subkey to create.</param>
        /// <returns>New RegistryKey create as a volatile key.</returns>
        public static RegistryKey CreateVolatileSubKey(RegistryKey key, string name)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            //find the first slash to split the key name on
            int slashIndex = key.Name.IndexOf('\\');
            //handle to root key
            uint rootHKey = 0;
            //name of new subkey - removed the root and appended the subkey name
            string subkeyName = key.Name.Substring(slashIndex+1, key.Name.Length - slashIndex) + "\\" + name;
            //handle for newly created key - since we open this through the managed API well need to release this handle first.
            uint newKey = 0;
            NativeMethods.KeyDisposition disp = 0;

            //get root key
            switch(key.Name.Substring(0,slashIndex))
            {
                case "HKEY_CLASSES_ROOT":
                    rootHKey = (uint)NativeMethods.RootKeys.ClassesRoot;
                    break;
                case "HKEY_CURRENT_USER":
                    rootHKey = (uint)NativeMethods.RootKeys.CurrentUser;
                    break;
                case "HKEY_LOCAL_MACHINE":
                    rootHKey = (uint)NativeMethods.RootKeys.LocalMachine;
                    break;
                case "HKEY_USERS":
                    rootHKey = (uint)NativeMethods.RootKeys.Users;
                    break;
            }

            //create the volatile child
            int result = NativeMethods.RegCreateKeyEx(rootHKey, subkeyName, 0, null, 1, 0, IntPtr.Zero, ref newKey, ref disp);

            if (result < 0)
            {
                throw new System.ComponentModel.Win32Exception(result, "Error occured creating registry key");
            }

            //close the newly created key
            if (newKey != 0)
            {
                result = NativeMethods.RegCloseKey(newKey);

                if (result < 0)
                {
                    throw new System.ComponentModel.Win32Exception(result, "Error occured closing registry key");
                }
            }

            //return the new key
            return key.OpenSubKey(name, true);
        }
        #endregion

    }
}
